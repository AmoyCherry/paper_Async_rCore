## 摘要

1. 协程受欢迎的原因是，基于有限状态机的协程切换具有极小的切换开销。
    1. 第二句话有描述：“低开销的协作式切换是并发编程的有效工具”；
2. 你的协程模型可以实现抢占式切换，从而把低延时的线程切换和低开销的协程切换统一到一起了。是这样吗？
    1. 目前的情况是，在保留了线程上下文切换机制的基础上，允许协程的协作式切换。问题在于：
        1. 这种性质能否被描述为统一；
        2. 如果可以，那么目前的goroutine及其它用户态协程也是运行在一个线程中，它们都可以使用线程的上下文切换响应中断，这篇论文在这个问题上并没有推进；
## 引言

1. 第一段没有说清楚。由于线程切换不能复用栈，而协程切换可复用栈资源，从而协程在高并发情况下具有较少的栈资源开销。
    1. 第一段只是概括地描述协程切换不会引起栈切换，而线程的栈切换会成为高并发的瓶颈，引出协程这个值得研究的对象；
    2. 复用栈（动态绑定）的具体描述在2.1；
    3. 要给出复用栈这次描述，必然要先给出“协程包裹着一个异步函数，它运行在一个栈上”，否则只能概括为切换不引起栈切换；
2. 1.1节第一段的协程定义是包括用户线程和无栈协程这两种情况的。这是你想表达的吗？
    1. 1.1是引用的其它论文里对于协程的定义。
3. 1.1节第二段是想说协程与线程的区别吗？我没有搞清楚你想说什么。
    1. 是在描述二者区别。准备删除；
4. 1.2节第二段：什么是“惰性状态机”？
    1. 删除“惰性”二字；
5. 建议把1.2节的第一段和第三段合并成一段。
    1. 赞同，应该合并；
6. 关于rCore的介绍，需要同时说它的优点和缺点。优点是你选它的原因，缺点是你要改进的地方。
    1. 有思考过这个问题。但唯二能想到的优点是“实现简洁”，“文档健全”。
    2. 内存管理，进程管理，充分利用了rust语言的特征，便于异步的扩展、开发；
    3. 文章描写的角度并不是针对rcore进行改进，所以只提到它没有实现协程，而我实现了一个协程库，恰好可以用上去；没有选择去描述，rcore因为没有协程而导致的缺点。
7. 1.3节的第二个特点，需要在摘要中提到你的“调度算法”和“其他进程中协程状态的感知（拥有最高优先级协程的进程）”。
    1. 摘要中有描述：“并且通过引入内核优先级位图，使得内核可以通过优先级感知用户态的协程的存在，从而干预整个系统的协程调度。”
## 第二节

1. 2.1节的协程模型，需要有一个简要的描述“协程是一个与全局异步函数一一对应的处理机调度对象”。Rust语言提供与异步函数对象和对象的状态数据结构，协程库提供优先级字段，并封装成协程控制块（CCB）。内核维护的就绪协程最高优先级位图也应该在这里出现。
    1. 准备以此作为2.1节第一段，然后在介绍协程模型的各个部分；
2. 第一段：第一个介绍的应该是“协程模型”，而不是“模型的运行机制”。
    1. 我认为应该描述模型 + 运行机制；也就是在现在的基础上，在2.1之前通过架构图增加对于整个模型的各个部分描述；
3. 输入错误：“完成的协程机制”应该是“完整的协程机制”
    1. 已改正；
4. “异步函数因为主动让出引起的切换不需要保存上下文”描述不准确。应该是“主动让出时由于栈为空而不用保存栈的状态”。
    1. 栈不一定为空，只是相对于该异步函数来说，栈上已经没有了该异步函数的内容，这一点在“.....不需要保存上下文”之前已作出解释；
5.  建议把协程控制块的描述与协程执行过程的描述放在不同的段落中。
    1. 协程控制块的描述，加上补充的模型的描述，放到2.1开篇；
6. “动态绑定”没有说清楚。栈是处理机的资源；协程与栈绑定后形成线程并在处理机上执行。执行状态的协程主动让权时，解除绑定；执行状态的协程被抢占时继续占有栈，被视为线程切换。
    1. 动态绑定这一段只是对之前一段中所描述的现象的总结，前一段中有更仔细的描述；
    2. 不准备使用“形成线程”这个描述，容易带来不解：什么是“协程形成线程”，“协程数据结构与资源是否发生了变化”。
    3. “形成线程”其实是指协程可以使用栈执行自己的异步函数，以及可以使用线程的中断机制响应中断，在2.1第二段介绍协程的执行时，已经给出相应描述；“形成线程”是一个范围更大的描述；
7. 2.2节：协程接口参数中有优先级吗？
    1. 添加描述：“可以通过接口指定协程优先级，如果不指定，则为默认值”；
8. 2.3.1节：协程创建和协程启动的使用有什么限制吗？
    1. “任意线程的任意位置”都可以启动；
    2. “任意线程的任意位置”都可以创建；
9. 协程状态和变迁事件需要集中和完整地描述。
10. 2.4节的内容应该就是协程状态变迁描述中的一部分。这部分内容组织顺序还需要语音讨论后改进。
## 第三节

实验结果分析不仅要描述现象，还尝试解释原因。

随着并发的增大，线程的栈切换带来的性能减益影响越来越明显，而协程没有栈的切换、回收开销，所以并发增大时任务切换的影响小于线程。

对此我在第三节最后一段做了解释。


## 第四节

结论要呼应摘要和第一节的贡献描述，并强调关键的定量数据支持。

1. 第一段有再次概括贡献：
    1. 提出并实现了一个协程模型；
    2. 可以在内核态和用户态创建协程；
    3. 优先级，进程之内与进程之间；
2. 在第二段中补充实验的定量数据；





# 20221014-王文智的小论文第二稿修改

王文智、小论文、修改意见、

* 修改后的[第二版论文](https://github.com/AmoyCherry/papper_Async_rCore/blob/6e8909c80cc90f2ffe745044022999542946ea2a/draft.md)

## 向勇的修改意见

1. 2.1节第一段：管理协程的数据结构可以称为协程控制块（CCB, Coroutine Control Block）。
2. 建议在图1中对就绪协程的最高优先级位图有所表示。
3. 建议在2.2节的接口定义部分给出两个函数的完整接口定义。
4. 2.3.2.1节的位图描述需要一个插图，直观表示每个进程的位图和整个系统的位图的关系。
5. 2.3.2.2节中的内核位图应该与系统位图是两个东西。对吗？
6. 建议2.4节加一个图表示协程的状态和状态间的转换，类似于三状态进程模型的图。
7. 3.1节中的“把协程和线程统称为task”不恰当。“进程”也有人称为“任务（task）”。这里的描述有些乱，我没有太理解（特别是“第三步”）。我对这个实验步骤的理解是，在每个进程中分别创建若干协程或线程来执行一个操作序列（你说的task），然后统计执行时间。
8. 3.1节的“读操作”和“写操作”是从哪儿读多少数据？
9. 3.1节的实验中，可以说一下协程和线程方式下的并发量最大值信息。
10. 3.1节和3.2节的实验步骤描述还有些乱，请尝试简洁和清晰一些的描述。如在步骤描述中只描述步骤。
11. 把实验结果的插图加到文章中。
