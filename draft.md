### A Coroutine Implementation of Operating System in Rust

> 贡献：
>
> 1. 我提出了一种Rust OS中的协程模型，利用Rust语言层面提供的异步函数封装出了协程，【具体的区别】使得操作系统可以感知；
> 2. 我添加了优先级机制，通过对优先级的控制，使得内核可以感知到协程的存在，使得系统总是能及时执行整个系统（内核态和用户态）中优先级最高的协程；
> 3. <u>通过VDSO向内核与用户态提供统一协程接口</u>（协程用法：低耦合，易用，对原代码的修改需求较小），并且利用内核协程来实现系统调用，对比与同步syscall，这可以<u>提高线程的并发程度</u>（线程+syscall会阻塞整个线程，协程+asyncall只会阻塞协程），并<u>减少内核执行系统调用的切换开销</u>；
>3. 我在rcore中实现了这种模型，我设计并进行了实验得到结论；

内核调用库，映射到用户态

# Abstract 

1. ”协程模型“需要体现特点，与他人的差异，优先级、VDSO、共享；

## Keywords





# 1. INTRODUCTION

> 总结自己的工作

## 1.1 Coroutines

> 1. 简要介绍线程，然后引出协程，做对比，强调协程特性： stackless ，用figure辅助描述；（参考CoroBase）
> 2. 简单综述，介绍目前进展；



## 1.2 Rust and rCore OS

> 1. 简要介绍Rust作为<u>系统级软件</u>的开发语言的优势，以及对于异步的支持（异步机制介绍，async, await, waker）；（参考Rust官方文档）
>
> 2. 引出rcore，并指出目前的rcore没有充分利用rust得异步机制;



## 1.3 Contributions and Paper Organization



# 2.  COROUTINE MODEL DESIGN

> coroutine model and implementation 
>
> 8月17日完成
>
> ds，接口，优先级
>
> 架构图

> 1. 描述架构图；
> 2. 通过优先级，协程可以被操作系统感知，从而实现灵活切换，在这一节可以描述各种调度情况和过程；
> 3. ~~用户态与内核态使用统一的调度代码；~~
> 4. 接口封装；



这一章会描述此协程模型的整体框架与设计细节。我们先介绍模型的运行机制，然后介绍此模型提供的接口的使用方法和功能，之后我们再介绍协程的设计和运行过程，以及协程的异步机制，最后我们会介绍模型的调度框架。



## 2.1 Overview

![overview](/Users/wangwenzhi/doc_markdown/论文/paper_src/overview.png)



此协程模型提供了一种协程的工作和使用方式，相比于【section1】中提到的Rust利用编译器在语言层面提供的协程，本模型的用户态协程可以通过优先级被内核感知，即，用户态的协程的执行可以像进程与线程一样，用户态的协程调度不再是各个进程之内的独立行为，而是所有进程的所有协程可以被内核统一控制。

每个进程的协程统一存放在进程的堆内存中，如【上图】所示，模型会在协程ID和协程的数据结构之间建立映射，因此，我们在调度器中就可以只保存协程ID（一个32位或64位整数，取决于机器字长），相比于直接存在协程的数据结构，这样可以减少调度器工作时的内存移动开销。

调度器可以弹出当前进程中，处于就绪状态的最高优先级协程的ID，通过ID作为key，就可以得到协程的数据结构，然后取出其中的异步函数（即协程主函数）执行。函数的执行必然要依赖于栈，我们在此引入“动态绑定”的概念，即，当一个协程需要执行时，会寻找或创建一个空闲的线程，这个线程我们称之”协程执行器“，此线程的栈会被被调度的协程所占用，当协程执行完毕或主动让出，会退出所占据的线程栈，此时“协程执行器”线程空闲，其线程栈可以被下一个协程复用。

我们可以发现，不同的协程执行，可以使用同一个线程的同一个栈，对比于线程，减少了栈内存的分配与回收的开销，这是协程本身的优势，而用户态协程可以被内核感知的工作会在2.3节中详细介绍。



## 2.2 Interface

此模型向外提供两个接口，创建协程和启动协程执行器，我们将这个模型实现为一个函数库，用户态与内核态都可以像调用库函数一样使用这两个接口。

创建协程的接口要求传入一个异步函数，其中封装了这个协程需要执行的指令语句。Rust语言中，只需要在普通函数声明前添加async关键字，即可将函数声明为异步函数。协程创建接口会把传入的异步函数封装为协程，并插入协程队列，等待被调度执行。

启动协程执行器接口可以跳转到负责调度并执行协程的函数，调用此接口的线程称之为协程执行器。只要进程中存在协程执行器，就不需要再调用此接口；如果进程中有协程等待被执行，且没有协程执行器，此时就可以调用此接口执行协程，当此前创建的所有协程，以及协程执行过程中创建的协程全部执行完毕时，协程执行器退出，此接口返回。



## 2.3 Priority and Schedule

每个协程的数据结构包含3个成员变量：ID，优先级，异步函数。协程ID在进程内唯一表征了一个协程，可以与协程组成哈希表中的键值对；优先级代表了协程的紧急状态，这会影响协程执行的先后顺序；异步函数中封装了协程需要执行的任务内容，可以理解为协程主函数，它可以像普通的线程主函数一样，执行用户态的普通函数调用和系统调用，包括创建协程等，但是比普通的函数多了一个异步机制，这个特性将在【2.4】中具体介绍。

其中异步函数必须由添加协程接口传入，协程的优先级可以作为参数传入，也可以被模型指定为默认值。

### 2.3.1 进程之内的协程调度

每个进程都有唯一一个独立的优先级队列，存放在进程的堆内存中。优先级队列中保存处于就绪状态的协程的协程ID，调度器只针对协程ID进行操作，当需要协程时，可以通过协程ID映射得到。优先级队列中的协程都是可以立即被调度执行的，只是用优先级区分了执行的先后顺序，对于非就绪状态的协程，在被唤醒之后会重新插入到优先级队列中，具体过程会在【2.4】中介绍。

```python
# Algorithm 1
def excute:

```

本模型提供了一个从调度器获取协程并执行的函数，通过【2.2】中介绍的`coroutine_run`接口，就可以跳转到此函数，运行这个函数的线程称之为协程执行器。执行协程的函数如【Algorithm 1】所示，在一个loop循环中，从调度器获取一个协程ID，此时调度器会根据优先级从高到低访问队列，当出现第一个非空队列时，从队列中弹出一个协程ID，此时这个协程就是进程内优先级最高的协程之一。设优先级数为`N`，则调度器弹出最高优先级协程的时间复杂度为`O(N)`，一般来说，N的数量级为`1o^2`；如果所有队列为空，则进程内没有可以执行的协程，调度器会返回一个空值，此时会继续判断协程数量为否为0，即，是否存在处于等待状态的协程，如果不存在，则说明所有协程执行完成，可以退出协程执行器，如果存在，则会调用系统调用执行线程的主动让出。

得到协程ID之后，通过在插入协程到调度器时建立的映射关系，就可以在O(1)的时间内获得协程的异步函数，然后开始执行。

### 2.3.2 整个系统的协程调度

#### 2.3.2.1 优先级位图

每个进程会维护一个位图，长度，即比特位个数，为协程的优先级数，每一位的取值为0或1，代表进程中是否存在该优先级的协程。在每次插入协程ID或弹出协程ID时，如果某个优先级的队列从空变为非空，或是从非空变为空，都会修改进程位图中的对应位为1或0。

~~在X86架构中有两条位扫描指令【～～～】，可以直接得到一串数位的左起或右起第一个1的位置，借此可以使得【2.3.1】中所描述的调度器弹出最高优先级协程ID的时间复杂度从`O(N)`优化为`O(1)`，从执行数百次判断优化为执行一条指令，但目前在riscv中还没有这条指令。~~

我们在内核中也设置一个位图，长度为协程的优先级数，但每一位的0或1代表的是整个系统的所有进程中，是否存在该优先级的协程，这需要使内核可以访问到所有进程的位图，我们的做法是，指定一个虚拟地址作为进程在用户态访问位图的地址，在进程初始化时，从内核获取一个空闲的物理页面，将指定的进程的位图地址，与此物理页起始地址建立映射，并赋予进程读写的权限，就可以使得进程可以在用户态对位图进行读写，内核也可以直接访问到进程的位图。

我们将进程ID与进程位图的内核地址（如果内核采用对等映射，此时就是物理地址）建立映射，就可以通过遍历进程，找到每个进程对应的位图的内核地址。在每个时钟中断到来时，遍历所有进程的位图，更新内核位图，这里只需要对所有进程位图进行或运算，只要其中有一个进程的一个协程属于该优先级，内核位图中的对应位就是1，只有当所有进程都不存在该优先级的协程，内核位图的对应位才会是0，将所有进程位图的或运算结果赋值给内核位图，即完成了更新。

#### 2.3.2.2 基于优先级位图的全局调度

在系统具备了进程位图和内核位图之后，就可以进一步完善我们的调度机制。

有两种原因会导致一个协程退出执行，让出线程栈，即：执行结束和主动让出。无论是哪种情况，都会在之后进入下一轮循环，再次访问调度器获取协程并执行。在进入下一个循环之前，我们读取进程位图与内核位图，比较二者记录的最高优先级，相当于是在查询其他进程中是否存在更高优先级的协程，如果本进程中的协程最高优先级小于内核位图中记录的所有进程中的协程最高优先级，就会让出当前处理器；否则，继续执行。

在每个时钟中断到来，更新完内核位图之后，都会调度执行拥有整个系统的最高优先级协程的进程，该进程会调度执行进程的的最高优先级协程，也就是整个系统的最高优先级协程。

在一个时钟中断之内，进程的位图会随着协程的创建与回收而发生变化，但各个进程的位图变化在下一次时钟中断之前，不会同步到内核位图，所以有两种情况需要讨论：

1. 某个进程创建了一个协程，其优先级大于之前系统中记录的协程最高优先级，此时这个协程执行器会继续执行，在下一个循环中取出该优先级的协程执行。这种情况是符合预期的。

2. 进程中记录的最高优先级协程只有唯一一个，当这个协程执行完毕且没有插入相同或更高优先级的协程时，进程位图的最高优先级位会由1变为0，比较位图时，因为内核位图记录了更高的协程优先级（实际上该协程已经被执行完毕），而让出处理器，此时调度的进程就不一定拥有实际的最高优先级协程。

   针对这种情况，我们可以在每次进程让出处理器时再次更新位图，做到每当有协程执行，都必然是整个系统之内的最高优先级协程，但出于两个原因我们没有采取这种做法，而是允许一个时钟中断之内存在调度非最高优先级的协程的可能：

   1. 一个时钟中断之内更新多次位图，需要多次遍历所有进程，开销较大；
   2. 在每次时钟中断到来时都会更新位图并调度最高优先级协程执行；

## 2.4 Excutor and Asynchronization 

 Excutor是模型中的协程管理机构，负责管理上文提到的协程数据机构，优先级队列，以及本节要介绍的协程的唤醒机制。

当一个协程执行退出执行，让出所占据的线程栈时，有两种情况：

1. 协程执行完毕，协程主函数执行完成并返回，此时会根据协程ID查找到协程的数据结构并释放其所占据的堆内存；
2. 协程未执行完毕，由于等待某个事件到来而主动让出，此时的做法是，不把协程ID插入回调度队列，而直接进入下一轮循环，访问调度器取出下一个协程执行。当主动让出的协程等待的事件到来时，进行唤醒操作，也就是把被唤醒的协程ID插回调度队列。这就是本模型中的协程的异步机制。这样的设计保证了调度器的工作效率，调度队列里的每一个协程都处于可以立即执行的就绪状态，访问调度队列时不用判断协程的状态，也不会访问到等待状态的协程。

现在我们知道，要完成唤醒一个协程的操作，需要协程ID，协程优先级，优先级队列的地址。我们可以将这三个变量封装为一个数据结构称之为TaskWaker，并在协程ID和对应的TaskWaker之间建立起映射，当需要唤醒一个协程时，仅需要给出其协程ID。

所以现在的关键问题是，执行等待事件与唤醒操作的协程，怎样拿到等待被唤醒的协程ID。我们在此引入一个基于HashMap实现的数据结构称之为WakerMap，维护整数key值到协程ID的映射。对于等待的协程与执行唤醒操作的协程，它们需要在创建时传入相同的key值（这是容易实现的，只需要使用一个全局计数器），建立起联系，当需要等待的协程执行到等待操作时，把key值与协程ID的键值对插入到WakerMap，之后执行唤醒操作的协程进行唤醒时，就可以根据key值直接查找到需要被唤醒的协程ID，再根据TaskWaker就可以将处于等待状态的协程的协程ID插入回调度队列，完成唤醒操作；如果是执行唤醒操作的协程优先被调度执行，在查询WakerMap时就会查找到空项而直接跳过，当执行等待操作的协程执行时 ，会发现等待的事件早已到来（比如说缓冲区中的数据已经写入完成），便不会主动让出。



# 3. PERFORMANCE COMPARISON 

> 8月25日完成
>
> 对rcore的改造；
>
> 实验一：不涉及内核态，完全在用户态的测试；
>
> 实验二：管道读写，有内核态的参与；



我们在rCore OS上引入了这个协程库，使得rCore可以创建执行协程，而且设计并进行了实验，对比了



## 3.1 Experiment A



## 3.2 Experiment B



# 4. CONCLUSION

> 8月26日完成

1. 总结自己的工作，做出的贡献~~与不足~~；
1. 总结实验的结果；



# REFERENCES