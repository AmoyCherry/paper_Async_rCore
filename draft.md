# A Coroutine Implementation of Operating System in Rust

> 贡献：
>
> 1. 我提出了一种Rust OS中的协程模型，利用Rust语言层面提供的异步函数封装出了协程，【具体的区别】使得操作系统可以感知；
> 2. 我添加了优先级机制，通过对优先级的控制，使得内核可以感知到协程的存在，使得系统总是能及时执行整个系统（内核态和用户态）中优先级最高的协程；
> 3. <u>通过VDSO向内核与用户态提供统一协程接口</u>（协程用法：低耦合，易用，对原代码的修改需求较小），并且利用内核协程来实现系统调用，对比与同步syscall，这可以<u>提高线程的并发程度</u>（线程+syscall会阻塞整个线程，协程+asyncall只会阻塞协程），并<u>减少内核执行系统调用的切换开销</u>；
>3. 我在rcore中实现了这种模型，我设计并进行了实验得到结论；

内核调用库，映射到用户态

# Abstract 

1. ”协程模型“需要体现特点，与他人的差异，优先级、VDSO、共享；

## Keywords





# 1. INTRODUCTION

> 总结自己的工作

## 1.1 Coroutines

> 1. 简要介绍线程，然后引出协程，做对比，强调协程特性： stackless ，用figure辅助描述；（参考CoroBase）
> 2. 简单综述，介绍目前进展；



## 1.2 Rust and rCore OS

> 1. 简要介绍Rust作为<u>系统级软件</u>的开发语言的优势，以及对于异步的支持（异步机制介绍，async, await, waker）；（参考Rust官方文档）
>
> 2. 引出rcore，并指出目前的rcore没有充分利用rust得异步机制;



## 1.3 Contributions and Paper Organization



# 2.  COROUTINE MODEL DESIGN

> coroutine model and implementation 
>
> ds，接口，优先级
>
> 架构图

> 1. 描述架构图；
> 2. 通过优先级，协程可以被操作系统感知，从而实现灵活切换，在这一节可以描述各种调度情况和过程；
> 3. ~~用户态与内核态使用统一的调度代码；~~
> 4. 接口封装；



这一章会描述此协程模型的整体框架与设计细节。我们先介绍模型的运行机制，然后介绍此模型提供的接口的使用方法和功能，之后我们再介绍协程的设计和封装过程，以及协程的异步执行过程，最后我们会介绍模型的调度框架。



## 2.1 Overview

![overview](/Users/wangwenzhi/doc_markdown/论文/paper_src/overview.png)



此协程模型提供了一种协程的工作和使用方式，相比于【section1】中提到的Rust利用编译器在语言层面提供的协程，本模型的用户态协程可以通过优先级被内核感知，即，用户态的协程的执行可以像进程与线程一样，用户态的协程调度不再是各个进程之内的独立行为，而是所有进程的所有协程可以被内核统一控制。

每个进程的协程统一存放在进程的堆内存中，如【上图】所示，模型会在协程ID和协程的数据结构之间建立映射，因此，我们在调度器中就可以只保存协程ID（一个32位或64位整数，取决于机器字长），相比于直接存在协程的数据结构，这样可以减少调度器工作时的内存移动开销。

调度器可以弹出当前进程中，处于就绪状态的最高优先级协程的ID，通过ID作为key，就可以得到协程的数据结构，然后取出其中的异步函数（即协程主函数）执行。函数的执行必然要依赖于栈，我们在此引入“动态绑定”的概念，即，当一个协程需要执行时，会寻找或创建一个空闲的线程，这个线程我们称之”协程执行器“，此线程的栈会被被调度的协程所占用，当协程执行完成或主动让出，会退出所占据的线程堆栈，此时“协程执行器”线程空闲，其堆栈可以被下一个协程复用。

我们可以发现，不同的协程执行，可以使用同一个线程的同一个栈，对比于线程，减少了栈内存的分配与回收的开销，这是协程本身的优势，而用户态协程可以被内核感知的工作会在2.3节中详细介绍。



## 2.2 Interface

此模型向外提供两个接口，添加协程和运行协程。

添加协程接口传入一个异步函数和优先级，优先级可以缺省由系统分配。

运行协程接口可以跳转到协程执行的函数，调用此接口的线程会作为协程执行器运行。





## 2.3 Coroutine with Priority

每个协程的数据结构包含3个成员变量：ID，优先级，异步函数。其中异步函数必须由添加协程接口传入。





## 2.4 Excutor and Asynchronization 

 Excutor是模型中的协程管理机构，负责管理上文提到的协程数据机构，优先级队列，以及本节要介绍的协程的唤醒机制。

当一个协程执行退出执行，让出所占据的线程栈时，有两种情况：

1. 协程执行完毕，协程主函数执行完成并返回，此时会根据协程ID查找到协程的数据接口并释放其所占据的堆内存；
2. 协程未执行完成，由于等待某个事件到来而主动让出，此时的做法是不把协程ID插入回调度队列，而直接访问调度器取出下一个协程执行。当主动让出的协程等待的事件到来时，进行唤醒操作，也就是把被唤醒的协程ID插回调度队列。这就是本模型中的协程的异步机制。这样的设计保证了调度器的工作效率，调度队列里的每一个协程都处于可以立即执行的就绪状态，访问调度队列时不用判断协程的状态，也不会访问到等待状态的协程。

现在我们知道，要完成唤醒一个协程的操作，需要协程ID，协程优先级，优先级队列。我们可以将这三个变量封装为一个数据结构称之为TaskWaker，并在协程ID和对应的TaskWaker之间建立起映射，当需要唤醒一个协程时，仅需要给出其协程ID即可。

所以现在的关键问题是，执行等待事件与唤醒操作的协程，怎样拿到等待被唤醒的协程ID，我们在此引入一个HashMap的数据结构称之为WakerMap，维护整数key值到协程ID的映射。对于等待的协程与执行唤醒的协程，它们需要创建时传入相同的key值（这是容易实现的，只需要使用一个全局计数器），建立起联系，当等待的协程执行到等待操作时，把key值与协程ID的键值对插入到WakerMap，之后执行唤醒操作的协程进行唤醒时，就可以根据key值直接查找到需要被唤醒的协程ID，再根据TaskWaker就可以将处于等待状态的协程的协程ID插入回调度队列，完成唤醒操作。





## 2.5 Scheduler



```python
# Algorithm 1  Scheduler for Coroutine

def excute():
  while TRUE:
    tid = SCHEDULER.pop()
    if tid not exit:
      break
    task = get_task_by_ID(tid)
    ret = task.run();
    if ret == Finish:
      del_task_by_ID(tid)
  
```







# 3. IMPLEMENTATION

> 1. ~~协程由async func封装为带优先级的coroutine，存储在堆上；（简短伪代码）~~
> 2. ~~Excutor管理coroutine，以及主动让出，唤醒过程；（figure）~~
> 3. ~~Scheduler 的工作流程；（figure）~~
> 4. 位图；
> 5. 调度的实现；
> 6. VDSO；



## 3.2 VDSO



# 4. PERFORMANCE COMPARISON 

> 对rcore的改造；
>
> 实验一：不涉及内核态，完全在用户态的测试；
>
> 实验二：管道读写，有内核态的参与；



## 4.1 Experiment A



## 4.2 Experiment B



# 5. CONCLUSION

1. 分析协程切换开销的减少，并且得到实验验证；



# REFERENCES