### A Coroutine Implementation of Operating System in Rust



# Abstract 



协程是近年来越来越受欢迎的一个程序设计模型，它的非阻塞式异步和非抢占式调度两大特征在现代编程中的应用非常广泛。目前针对协程的研究和应用主要集中于用户态的应用程序之内，协程的调度完全是单个进程之内的行为，而且其在内核中的研究与应用很少。Rust是一门注重高性能和内存安全的编程语言，非常适合底层系统的开发。本文基于Rust语言的异步机制，提出了一种带优先级的协程模型，可以做到基于优先级的协作式调度，并且通过引入内核优先级位图，使得内核可以感知用户态的协程的存在，从而干预进程的协程调度。进一步的，本文将此模型实现为一个函数库，它可以应用于一个使用Rust语言编写的OS中，而且可以被内核引入使用，在内核中创建、运行协程。最后，我们通过实验横向对比了引入协程库使用协程的OS，和未引入协程库使用线程的OS之间的性能差异，结果显示，在一定的并发量下，使用协程完成任务的总时间明显小于线程。



## Keywords

Coroutines, Asynchronous Programming, Operating System, Schedule, Rust



# 1. INTRODUCTION



在现代编程中，协程主要是作为non-blocking asynchronous programming的抽象来设计和使用。【**Reference**】Asynchronous procedures are procedures whose progression may involve waiting for external events to transpire, but allow for other components of the program to execute while waiting.且由于主动让出而引发的切换不会引起页表（进程）的切换，不会引起栈（线程）的切换，不需要内核的参与。多线程技术的栈切换开销会由于并发量的不断增加而成为系统的性能瓶颈，此时，协程就会是一个有效的解决方案。



## 1.1 Coroutines and Related Work



> 协程定义 ⬇️⬇️⬇️
>

In the most general sense, coroutines【**UPPSALA Univ. Reference**】 are a generalization of subroutines, equipped with the ability to suspend their own execution, and be resumed by another part of the program later, at which point the coroutine continues execution at the point it previously suspended itself, up until the next suspension or the termination of the coroutine.

同样作为调度和运行的实体，协程和线程有着两大区别：1. 如前文所说，协程在运行时具有异步特征；2. context switching of coroutines is cooperative, there is no need for a mechanism to interrupt the execution of a coroutine, and no strict need for kernel – although the latter may be desirable depending on the design and implementation.所以，就上下文切换这一个操作而言，协程必然优于线程，但在实际的运行中，由于异步和回调机制的具体实现的不同，使得协程并非在所有场景下都能表现出比线程更好的性能。但从另一个方面来看，在某些场景使用协程会带来可观收益，这是值得我们探索和研究的问题，并且已经有开发人员使用协程开发出了很多应用广泛的知名项目，它们会在下文提及。

> 协程有很多人用，有很好的产品---> 值得研究  ⬇️⬇️⬇️

关于协程的最早的描述由Melvin Conway【**reference**】于1958年提出，它是计算机科学领域中一个经过多年发展且备受欢迎的抽象，目前有许多函数库和编程语言都提供了协程的使用接口，包括在语言层面直接提供协程支持的Go，kotlin，Lua等，以及Windows Fiber(C++)，libco(C++)，tokio(Rust)等协程库。基于这些语言和函数库提供的协程，编程人员开发出了许多实用的产品，如docker（基于Go语言，可以在一台物理服务器上快速运行多个实例的虚拟化技术），WeChat（基于 libco，A Social software that serves 2 billion people）。



## 1.2 Rust and rCore OS



Rust是一种兼顾开发效率和执行效率的语言，没有垃圾回收机制，拥有堪比于C++的运行速度和较高的内存利用率，并且通过严格的类型检查和所有权模型保证了内存安全和线程安全。

Rust虽然没有在语言层面的提供完备的协程机制，但是提供了`async`异步编程模型（async代码的运行依赖于库函数的实现）。Rust编译器会将被`async`修饰的代码块或函数生成为一个惰性状态机，它的使用分为构造和执行两步，执行需要主动触发，每一次从主动让出点恢复执行时，都能从上一次让出的地方继续执行。所以我们可以使用`async`关键字创建异步函数，保存需要执行的任务内容，并将其封装为协程。

> 为什么要用Rust作为开发语言 ⬇️⬇️⬇️

Rust语言的高性能、内存安全与并发安全等优势，使其非常适合底层软件的开发，在区块链和操作系统领域有很多知名项目，例如Facebook（Meta）开发的加密货币Libra，Google开发的新一代跨平台操作系统Fuchsia，Dropbox 的用于处理数万PB的数据规模的底层存储服务，，以及AWS和Microsoft在其云计算平台中大量使用了Rust重写服务和提供组件。

rCore OS是清华大学开发的一款运行于RISC-V平台之上的类Unix OS，支持基本的进程调度和线程调度，但不支持协程，本文把实现的协程库应用在了rCore OS之上，并设计了实验对比rCore OS中的线程与协程的性能差异。



## 1.3 Contributions and Paper Organization

本文的主要工作有两点：

1. 提出了一种基于Rust语言特性的协程模型，并用Rust语言将其实现为一个函数库。值得注意的是，本函数库完全基于Rust的核心库实现，所以可以被内核引入使用，使得内核也可以创建、运行协程。而标准库需要有OS的支持，所以不能应用于内核，这是与目前已有的一些只能运行于用户态的协程库（如tokio）的重要区别。
2. 本文为协程引入了优先级，并参考Linux的O(1)调度算法，实现了协程的优先级调度。基于每个进程的优先级位图，进程内的协程按照优先级被调度执行；基于内核的全局优先级位图，每次时钟中断之后，内核会调度拥有最高优先级协程的进程，该进程会在稍后调度运行该进程内，同时也是整个系统内的最高优先级协程。这个机制使得协程调度不再是各个进程内的独立行为，而是所有进程的协程可以通过优先级被内核统一控制。

本文在接下来的第二章中会介绍（present）协程模型的设计与实现细节，第三章中给出性能对比实验并在第四章做出总结。



# 2.  COROUTINE MODEL DESIGN



这一章会描述此协程模型的整体框架与设计细节。我们先介绍模型的运行机制，然后介绍此模型提供的接口的使用方法和功能，之后我们再介绍协程的设计和运行过程，以及协程的异步机制，最后我们会介绍模型的调度框架。



## 2.1 Overview

![overview](https://github.com/AmoyCherry/papper_Async_rCore/blob/main/papper_src/overview.png)



此协程模型提供了一种协程的工作方式，它会以函数库的方式被应用程序和内核引入使用，并且不需要修改原来的进程和线程的实现，它们可以正常工作。

我们使用Rust的`async`关键字创建异步函数，封装出称之为协程控制块的数据结构，包含了协程需要执行的任务内容（一个异步函数）和优先级等，并将其放置在堆内存中，此时，协程可以被看作是进程内一个全局的异步函数。函数的执行必然要依赖于栈，对此我们有如下设计：当一个协程需要执行时，会寻找或创建一个空闲的线程，这个线程我们称之”协程执行器“，它会在一个loop循环中依次取出所有处于就绪状态的协程并执行，此线程的栈会被即将执行的协程所占用，当协程执行完毕或主动让出，会退出所占据的线程栈，此时“协程执行器”线程空闲，它的栈将被下一个协程使用。如果不存在就绪协程，那么协程执行器线程跳出循环并结束。

我们在此引入“动态绑定”的概念，即：协程（异步函数）的执行需要栈，但是协程在多次主动让出与重新执行的过程中，有可能在多个不同的栈上执行；而同一个栈也总是会执行不同的协程。

程序通过调度器提供的接口访问协程，包括创建、插入，取出、查询就绪协程数等。当访问调度器时，它会弹出当前处于就绪状态的所有协程中的最高优先级协程。考虑协程会主动让出的特性，它会在其生命周期中会多次插入并弹出任务队列，所以我们在协程ID和协程的数据结构之间建立映射，如此，我们在调度器中就可以只保存协程ID（一个32位或64位整数，取决于机器字长），相比于直接存储协程，这样做可以减少调度器工作时的内存移动开销。

优先级队列与调度器的具体设计与实现我们在2.3节中介绍，而异步函数的运行，包括主动让出和唤醒机制我们在2.4中介绍。



## 2.2 Interface

/*

此模型向外提供两个接口，创建协程和启动协程执行器，我们将这个模型实现为一个函数库，用户态与内核态都可以像调用库函数一样使用这两个接口。

创建协程的接口要求传入一个异步函数，其中封装了这个协程需要执行的指令语句。Rust语言中，只需要在普通函数声明前添加async关键字，即可将函数声明为异步函数。协程创建接口会把传入的异步函数封装为协程，并插入协程队列，等待被调度执行。

启动协程执行器接口可以跳转到负责调度并执行协程的函数，调用此接口的线程称之为协程执行器。只要进程中存在协程执行器，就不需要再调用此接口；如果进程中有协程等待被执行，且没有协程执行器，此时就可以调用此接口执行协程，当此前创建的所有协程，以及协程执行过程中创建的协程全部执行完毕时，协程执行器退出，此接口返回。

*/



## 2.3 Priority and Schedule

/*

每个协程的数据结构包含3个成员变量：ID，优先级，异步函数。协程ID在进程内唯一表征了一个协程，可以与协程组成哈希表中的键值对；优先级代表了协程的紧急状态，这会影响协程执行的先后顺序；异步函数中封装了协程需要执行的任务内容，可以理解为协程主函数，它可以像普通的线程主函数一样，执行用户态的普通函数调用和系统调用，包括创建协程等，但是比普通的函数多了一个异步机制，这个特性将在【2.4】中具体介绍。

其中异步函数必须由添加协程接口传入，协程的优先级可以作为参数传入，也可以被模型指定为默认值。

*/



### 2.3.1 进程之内的协程调度

协程具有优先级属性，处于相同优先级的协程的ID被同一个队列管理，多个不同的优先级会对应多个不同的队列，它们组成一个队列组，每个进程有且仅有一组优先级队列，存放在进程的堆内存中，当需要协程其他信息时，可以通过协程ID映射得到。优先级队列中的协程都处于就绪态度，也就是都可以立即被调度执行，只是用优先级区分了执行的先后顺序，对于非就绪状态的协程，在被唤醒之后会重新插入到优先级队列中，具体过程会在【2.4】中介绍。

```python
# Algorithm 1
def excute(bool wait):

```

在任意线程的任意位置，我们可以调用【2.2】中的`coroutine_run`接口执行协程。该接口会最终跳转至`excute`函数，它如【Algorithm 1】所示，会在一个loop循环中，从调度器获取一个协程ID，此时调度器会根据优先级从高到低访问队列，当出现第一个非空队列时，从队列中弹出一个协程ID，此时这个协程就是该进程内可以立即执行的优先级最高的协程之一。

如果所有队列为空，则进程内没有可以执行的协程，调度器会返回一个空值。此时会进一步判断协程数量为否为0，即，是否存在处于等待状态的协程。如果不存在，则说明所有协程执行完成，可以退出协程执行器，如果存在，则根据传入的参数，选择退出`excute`函数，或是调用系统调用执行线程的主动让出。

协程退出执行有两种情况：1、执行完成，此时会回收协程所占据的堆内存；2、由于等待其它事件而主动让出，此时不执行任何操作，当协程被唤醒时会重新插入调度队列。

显然地，这种设计的一个好处就是，调度器工作时只需要考虑就绪状态的协程，不需要去枚举所有协程，判断它们的状态而进行选择。

### 2.3.2 整个系统的协程调度

基于前文的设计，可以在进程之内实现协程的优先级调度，现在我们把它推广到整个系统中，对所有进程的协程进行优先级调度。这需要在内核中获取到所有进程的协程的优先级信息，并记录拥有最高优先级的协程的进程，随后从内核切换到用户态时，调度该进程，就可以在该进程内调度运行最高优先级协程。

#### 2.3.2.1 优先级位图

我们使用位图处理协程的优先级信息。

每个进程会维护一个位图，它的长度，即比特位个数，为协程的优先级数，每一位的取值为0或1，代表进程中是否存在该优先级的协程。当访问调度器插入协程或获取协程时，如果某个优先级的队列从空变为非空，或是从非空变为空，都会修改进程位图中的对应位为1或0。

我们在内核中也设置一个位图，长度为协程的优先级数，但每一位的0或1代表的是整个系统的所有进程中，是否存在该优先级的协程，这需要使内核可以访问到所有进程的位图，我们的做法是，指定一个虚拟地址作为进程在用户态访问位图的地址，在进程初始化时，向内核申请一个空闲的物理页面，将指定的位图虚拟地址，与此物理页起始地址建立映射，并赋予进程读写的权限，就可以使进程在用户态对位图进行读写，内核也可以直接访问到进程的位图。

我们将进程ID与进程位图的内核地址（如果内核采用对等映射，此时就是物理地址）建立映射，就可以在内核中通过枚举进程，获取到所有进程位图的内核地址。

内核位图的取值基于所有的进程位图，在每个时钟中断到来时，遍历所有进程的位图，更新内核位图。这里只需要对所有进程位图进行或运算：只要其中有一个进程的一个协程属于该优先级，内核位图中的对应位就是1；只有当所有进程都不存在该优先级的协程，内核位图的对应位才会是0。把所有进程位图的或运算结果赋值给内核位图，即完成了更新。



#### 2.3.2.2 基于优先级位图的全局调度

目前的系统具备了进程位图和内核位图，可以实现在每次时钟中断之后总是调度拥有最高优先级协程的进程。在一个时钟中断之内，进程的位图会随着协程的创建与回收而发生变化，但各个进程的位图变化在下一次时钟中断之前，不会同步到内核位图。也就是说，当最高优先级协程退出执行（完成或主动让出），下一次时钟中断到来之前的这段时间之内，目前还不不遵循优先级调度。如果希望整个系统的所有协程在运行期间严格遵守优先级调度，我们提供如下设计。

协程会因为执行完成或主动让出从而退出执行，让出线程栈。无论是哪种情况，都会在之后进入下一轮循环，再次访问调度器获取协程并执行。在进入下一个循环之前，我们读取进程位图与内核位图，比较二者记录的最高优先级，相当于是在查询本进程内是否还有未执行的最高优先级协程。如果进程中的协程最高优先级小于内核位图中记录的所有进程中的协程最高优先级，就说明本进程内的最高优先级协程已经全部执行完成，此时调用`yield`系统调用让出当前处理器，进入内核更新内核位图并根据结果进行调度；否则，继续执行。

显然，如果要追求严格的优先级调度，会多次更新内核位图而引入大量开销，所以这个机制应该作为一个选项来提供。由于这是协程执行器的行为（由它决定是否判断内核位图），所以我们可以通过一个参数去控制它，默认情况下执行宽松的优先级调度，也就是只在每次时钟中断之后进入调度拥有最高优先级协程的进程，在一个时钟中断之内不更新内核位图。

## 2.4 Excutor and Asynchronization 

 Excutor是模型中的协程管理机构，负责管理上文提到的协程数据机构，优先级队列，以及本节要介绍的协程的唤醒机制。

当一个协程执行退出执行，让出所占据的线程栈时，有两种情况：

1. 协程执行完毕，协程主函数执行完成并返回，此时会根据协程ID查找到协程的数据结构并释放其所占据的堆内存；
2. 协程未执行完毕，由于等待某个事件到来而主动让出，此时的做法是，不把协程ID插入回调度队列，而直接进入下一轮循环，访问调度器取出下一个协程执行。当主动让出的协程等待的事件到来时，进行唤醒操作，也就是把被唤醒的协程ID插回调度队列。这就是本模型中的协程的异步机制。这样的设计保证了调度器的工作效率，调度队列里的每一个协程都处于可以立即执行的就绪状态，访问调度队列时不用判断协程的状态，也不会访问到等待状态的协程。

现在我们知道，要完成唤醒一个协程的操作，需要协程ID，协程优先级，优先级队列的地址。我们可以将这三个变量封装为一个数据结构称之为TaskWaker，并在协程ID和对应的TaskWaker之间建立起映射，当需要唤醒一个协程时，仅需要给出其协程ID。

所以现在的关键问题是，执行等待事件与唤醒操作的协程，怎样拿到等待被唤醒的协程ID。我们在此引入一个基于HashMap实现的数据结构称之为WakerMap，维护整数key值到协程ID的映射。对于等待的协程与执行唤醒操作的协程，它们需要在创建时传入相同的key值（这需要在进程内使用一个互斥访问的全局计数器），建立起联系，当需要等待的协程执行到等待操作时，把key值与协程ID的键值对插入到WakerMap，之后执行唤醒操作的协程进行唤醒时，就可以根据key值直接查找到需要被唤醒的协程ID，再根据TaskWaker就可以将处于等待状态的协程的协程ID插入回调度队列，完成唤醒操作；如果是执行唤醒操作的协程优先被调度执行，在查询WakerMap时就会查找到空项而直接跳过，当执行等待操作的协程执行时 ，会发现等待的事件早已到来（比如说缓冲区中的数据已经写入完成），便不会主动让出。

基于上述的设计与实现，我们可以将本模型的协程调度概括为：考虑到整个系统（包括用户态和内核）内的处于就绪状态的协程，在每次时钟中断之后，会进入拥有最高优先级协程的地址空间，然后由该进程调度执行最高优先级协程。也就是说，如果用户态存在相比于内核态优先级更高的协程，那么会先调度执行用户态程序。



# 3. PERFORMANCE COMPARISON 

> 8月25日完成
>
> 对rcore的改造；
>
> 实验一：不涉及内核态，完全在用户态的测试；
>
> 实验二：管道读写，有内核态的参与；



我们在rCore OS上引入了这个协程库，使得rCore可以创建和执行协程，并且设计并进行了实验，对比了引用此协程库的rCore与未经修改的rCore，分别使用协程和线程执行相同任务的性能差异。



## 3.1 Experiment A: Test in user mode without syscall

此实验在用户态使用协程或线程进行普通的函数调用，不使用系统调用，没有内核参与。

本节中我们把协程和线程统称为task，设计如下实验：

1. 实验被创建为进程执行，每个进程内创建N个task执行任务，这N个task编号从0到N - 1。在进程开始时获取一个起始时间，在进程退出前获取一个结束时间，以二者时间差作为任务的总执行时间；
2. 每个task先执行读，后执行写；
3. 当读到的全局变量的值等于自己的task编号时，认为读取成功，可以执行写。当读取不成功，即task读到的变量值不等于自己的task编号时，协程使用异步机制主动让出，等待被唤醒；线程则可以采取原地忙等和主动让出两种策略，我们对这两种情况都进行了测试；
4. 编号为i的task读取成功之后执行写操作，把变量值修改为i + 1；



【Figure1: 协程与原地等待的线程】  【Figure2: 协程与主动让出的线程】  



从实验的结果我们可以看出，协程和线程的执行总时间都会随着并发数的增加而增加。协程的增长趋势接近于一条直线，也就是线性增长，而线程用时的增长速度却越来越快。当并发量较小时，协程完成任务的时间比线程要长【XX%】，随着并发量的增加，线程的用时将超过协程，且与协程的差距越来越大，当并发量到达4000时，协程的用时为线程的【XX%】。



## 3.2 Experiment B: Test in user mode with syscall

此实验在用户态进行，每个协程和线程都会使用读写系统调用，有内核参与。

本节中我们把协程和线程统称为task，设计如下实验：

1. 实验被创建为进程执行，每个进程内创建N个task执行任务，这N个task编号从0到N - 1。在进程开始时获取一个起始时间，在进程退出前获取一个结束时间，以二者时间差作为测试的总执行时间；
1. 我们创建N + 1个管道，编号从0到N，管道可以被读写。所使用的管道的工作方式为：只有当写端关闭时，对此管道的读操作才可以读取到数据然后完成读操作；当写端未关闭时，读操作会在内核引发线程切换；
1. 每个task执行管道的读写操作，具体来说，编号为i（0 <= i < N）的task会从编号为i的管道读取数据，待写入端关闭，读取成功后，向编号为i + 1的管道中写入数据，然后关闭编号为i的管道的写端，使得编号为i +1的task可以完成读操作，相当于使用管道把所有task串联起来，对同一个管道的读写操作分别位于编号相邻的两个task中。
1. 所有的task创建完成之后，测试进程的主线程会直接向管道0写入数据然后关闭它的写端，此后随着task的调度和执行，数据就会被编号为0的task从编号为0的管道中读出，然后写入管道1，编号为1的task再从管道1读取数据，然后写入管道2，以此类推；
1. 由于协程具备优先级属性，所以我们可以设置编号为0的协程拥有最高优先级，其余协程按照创建顺序依次插入次高优先级队列，这使得协程严格按照创建顺序执行，当第i + 1个协程执行读操作时，第i个协程必然已经执行完成，使得每次执行读操作都可以读取成功，不会引发线程切换从而创建多个协程执行器。这是利用协程的优先级性质控制协程执行的先后顺序，使其可以在某些场景提高程序性能的一个示例；



【Figure3: 使用读写系统调用的协程和线程】



从【Figure 3】中可以看出，当并发量较小时，协程的总执行时间比线程的多【XXX%】，随着并发量的增加，线程的执行总时间快速增加并超过协程，当并发量到达4000时，协程的总执行时间为线程的【XXX%】。



协程的总执行时间 = (单个协程的平均执行时间  + 平均切换时间 + 平均调度时间 + 平均唤醒开销) * 协程数。当并发量较小时，以上四个部分的总和比线程的总时间大，但是随着任务数量的增加，单个协程的平均执行时间 + 切换时间 + 调度时间 + 唤醒开销只是缓慢增长，我们可以根据协程执行时间的线性增长趋势得出这一推论。但是对于线程来说，增长趋势是一条下凸的曲线，随着并发数的增加，线程的切换时间和调度时间也会快速增加，使其与相同并发数的协程执行时间差距越来越大。



# 4. CONCLUSION

本文提出并实现了一个协程模型，一个Rust操作系统可以利用此协程库在用户态和内核态创建并执行协程。协程基于优先级调度运行，协程具备优先级属性。我们基于Linux的O(1)调度算法，设计了进程的协程优先级位图和内核的协程优先级位图，使得协程的调度不再是各个进程之内的独立行为，而是可以被内核统一控制，使得整个系统内，某些对于执行时间敏感的协程可以被优先调度，而一些对于执行时间不敏感的协程则可以设置较低优先级，减少与高优先级任务的争抢，使处理器可以更灵活、更科学地被分配。

我们在rCore OS上引入了此协程库并进行了性能对比实验，实验结果显示，并不是在所有情况下协程的性能都优于线程。当并发量较小时，协程的执行时间会大于线程，这是由于运行协程所需要的基本开销，如调度、切换和唤醒，对于并发数较小时的任务量来说，影响较大，但随着并发量的增加，协程的运行开销增长缓慢，而线程的运行开销增长迅速，且此劣势带来的影响越来越大，使得线程的执行时间超过协程，且二者差距越来越大。



# REFERENCES