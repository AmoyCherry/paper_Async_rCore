### A Coroutine Implementation of Operating System in Rust

> 贡献：
>
> 1. 我提出了一种Rust OS中的协程模型，利用Rust语言层面提供的异步函数封装出了协程，【具体的区别】使得操作系统可以感知；
> 2. 我添加了优先级机制，通过对优先级的控制，使得内核可以感知到协程的存在，使得系统总是能及时执行整个系统（内核态和用户态）中优先级最高的协程；
> 3. <u>通过VDSO向内核与用户态提供统一协程接口</u>（协程用法：低耦合，易用，对原代码的修改需求较小），并且利用内核协程来实现系统调用，对比与同步syscall，这可以<u>提高线程的并发程度</u>（线程+syscall会阻塞整个线程，协程+asyncall只会阻塞协程），并<u>减少内核执行系统调用的切换开销</u>；
>3. 我在rcore中实现了这种模型，我设计并进行了实验得到结论；

内核调用库，映射到用户态

# Abstract 

1. ”协程模型“需要体现特点，与他人的差异，优先级、VDSO、共享；

## Keywords





# 1. INTRODUCTION



## 1.1 Coroutines and Related Work

> 1. 简要介绍线程，然后引出协程，做对比，强调协程特性： stackless ，用figure辅助描述；（参考CoroBase）
> 2. 综述协程的发展；
>
> 3. OS领域两个知名的协程接口族：Windows Fiber，POSIX的用户上下文；



协程是可以自动挂起并在稍后恢复的程序片段。考虑到目前应用广泛的线程，每个线程依赖于栈而执行数个函数嵌套，每个线程都有一个私有的栈。协程可以看作是对线程的进一步拆分，这些协程可以共用同一个线程的栈，协程的切换在用户态完成，不需要通过系统调用让内核介入，是比线程切换更轻量级的切换。



关于协程的最早的描述由Melvin Conway【**reference**】于1958年给出“subroutines who act as the master program”，随后在其博士论文【**reference**】中给出了如下定义：

1. the values of data local to a coroutine persist between successive calls(协程的局部数据在后续调用中始终保持)；
2.  the execution of a coroutine is suspended as control leaves it, only to carry on where it left off when control re-enters the coroutine at some later stage(当控制流程离开时，协程的执行被挂起，此后控制流程再次进入这个协程时，这个协程只应从上次离开挂起的地方继续)。

此概念提出后的20年里（1960-1980）协程成为了程序设计语言中一个很受欢迎的概念，但随着multithreading技术的兴起，对协程的研究沉寂了很长一段时间。直到21世纪随着软件服务的发展，抢占式调度对IO型任务处理的低效逐渐受到重视，人们将目光再次投向协程。

2007年Go语言问世之时就在语言层面原生支持协程，Go为每个协程分配了协程栈和协程上下文，但是没有增加线程的数量，本质上还是使用同一个线程栈，只是在线程的基础上通过分时复用的方式运行多个协程。Go协程的轻量级切换带来的性能增益使得Go创造了很多经典项目，如docker（可以在一台物理服务器上快速运行多个实例的虚拟化技术），Kubernetes（简称K8S，由Google 公司开发的构建于 Docker 之上的容器调度服务）。



C++20



Lua



Windows Fiber



## 1.2 Rust and rCore OS

> 1. 简要介绍Rust作为<u>系统级软件</u>的开发语言的优势，以及对于异步的支持（异步机制介绍，async, await, waker）；（参考Rust官方文档）
>
> 2. 引出rcore，并指出目前的rcore没有充分利用rust得异步机制;

Rust是一种兼顾开发效率和执行效率的语言，没有垃圾回收机制，拥有堪比于C++的运行速度和较高的内存利用率，并且通过严格的类型系统和所有权模型保证了内存安全和线程安全，使得开发人员可以在编译期就消除各种各样的错误。

Rust虽然没有在语言层面的提供完备的协程机制，但是提供了`async`异步编程模型（async代码的运行依赖于库函数的实现）。Rust编译器会将被`async`修饰的代码块或函数生成为一个惰性状态机，也就是说async代码分为构造和执行两步，执行需要主动触发，每一次从主动让出点恢复执行时，都能从上一次让出的地方继续执行，也就是说async代码块具备协作式调度的行为，我们可以用它保存需要执行的任务内容，封装出协程的数据结构。



由于Rust语言的性能、内存安全与并发安全等优势，【区块链和操作系统的应用】



rCore OS是用Rust编写的操作系统，









## 1.3 Contributions and Paper Organization





# 2.  COROUTINE MODEL DESIGN

> coroutine model and implementation 
>
> 8月17日完成
>
> ds，接口，优先级
>
> 架构图

> 1. 描述架构图；
> 2. 通过优先级，协程可以被操作系统感知，从而实现灵活切换，在这一节可以描述各种调度情况和过程；
> 3. ~~用户态与内核态使用统一的调度代码；~~
> 4. 接口封装；



这一章会描述此协程模型的整体框架与设计细节。我们先介绍模型的运行机制，然后介绍此模型提供的接口的使用方法和功能，之后我们再介绍协程的设计和运行过程，以及协程的异步机制，最后我们会介绍模型的调度框架。



## 2.1 Overview

![overview](https://github.com/AmoyCherry/papper_Async_rCore/blob/main/papper_src/overview.png)



此协程模型提供了一种协程的工作和使用方式，相比于【section1】中提到的Rust利用编译器在语言层面提供的协程，本模型的用户态协程可以通过优先级被内核感知，即，用户态的协程的执行可以像进程与线程一样，用户态的协程调度不再是各个进程之内的独立行为，而是所有进程的所有协程可以被内核统一控制。

每个进程的协程统一存放在进程的堆内存中，如【上图】所示，模型会在协程ID和协程的数据结构之间建立映射，因此，我们在调度器中就可以只保存协程ID（一个32位或64位整数，取决于机器字长），相比于直接存在协程的数据结构，这样可以减少调度器工作时的内存移动开销。

调度器可以弹出当前进程中，处于就绪状态的最高优先级协程的ID，通过ID作为key，就可以得到协程的数据结构，然后取出其中的异步函数（即协程主函数）执行。函数的执行必然要依赖于栈，我们在此引入“动态绑定”的概念，即，当一个协程需要执行时，会寻找或创建一个空闲的线程，这个线程我们称之”协程执行器“，此线程的栈会被被调度的协程所占用，当协程执行完毕或主动让出，会退出所占据的线程栈，此时“协程执行器”线程空闲，其线程栈可以被下一个协程复用。

我们可以发现，不同的协程执行，可以使用同一个线程的同一个栈，对比于线程，减少了栈内存的分配与回收的开销，这是协程本身的优势，而用户态协程可以被内核感知的工作会在2.3节中详细介绍。



## 2.2 Interface

此模型向外提供两个接口，创建协程和启动协程执行器，我们将这个模型实现为一个函数库，用户态与内核态都可以像调用库函数一样使用这两个接口。

创建协程的接口要求传入一个异步函数，其中封装了这个协程需要执行的指令语句。Rust语言中，只需要在普通函数声明前添加async关键字，即可将函数声明为异步函数。协程创建接口会把传入的异步函数封装为协程，并插入协程队列，等待被调度执行。

启动协程执行器接口可以跳转到负责调度并执行协程的函数，调用此接口的线程称之为协程执行器。只要进程中存在协程执行器，就不需要再调用此接口；如果进程中有协程等待被执行，且没有协程执行器，此时就可以调用此接口执行协程，当此前创建的所有协程，以及协程执行过程中创建的协程全部执行完毕时，协程执行器退出，此接口返回。



## 2.3 Priority and Schedule

每个协程的数据结构包含3个成员变量：ID，优先级，异步函数。协程ID在进程内唯一表征了一个协程，可以与协程组成哈希表中的键值对；优先级代表了协程的紧急状态，这会影响协程执行的先后顺序；异步函数中封装了协程需要执行的任务内容，可以理解为协程主函数，它可以像普通的线程主函数一样，执行用户态的普通函数调用和系统调用，包括创建协程等，但是比普通的函数多了一个异步机制，这个特性将在【2.4】中具体介绍。

其中异步函数必须由添加协程接口传入，协程的优先级可以作为参数传入，也可以被模型指定为默认值。

### 2.3.1 进程之内的协程调度

每个进程都有唯一一个独立的优先级队列，存放在进程的堆内存中。优先级队列中保存处于就绪状态的协程的协程ID，调度器只针对协程ID进行操作，当需要协程时，可以通过协程ID映射得到。优先级队列中的协程都是可以立即被调度执行的，只是用优先级区分了执行的先后顺序，对于非就绪状态的协程，在被唤醒之后会重新插入到优先级队列中，具体过程会在【2.4】中介绍。

```python
# Algorithm 1
def excute:

```

本模型提供了一个从调度器获取协程并执行的函数，通过【2.2】中介绍的`coroutine_run`接口，就可以跳转到此函数，运行这个函数的线程称之为协程执行器。执行协程的函数如【Algorithm 1】所示，在一个loop循环中，从调度器获取一个协程ID，此时调度器会根据优先级从高到低访问队列，当出现第一个非空队列时，从队列中弹出一个协程ID，此时这个协程就是进程内优先级最高的协程之一。设优先级数为`N`，则调度器弹出最高优先级协程的时间复杂度为`O(N)`，一般来说，N的数量级为`1o^2`；如果所有队列为空，则进程内没有可以执行的协程，调度器会返回一个空值，此时会继续判断协程数量为否为0，即，是否存在处于等待状态的协程，如果不存在，则说明所有协程执行完成，可以退出协程执行器，如果存在，则会调用系统调用执行线程的主动让出。

得到协程ID之后，通过在插入协程到调度器时建立的映射关系，就可以在O(1)的时间内获得协程的异步函数，然后开始执行。

### 2.3.2 整个系统的协程调度

#### 2.3.2.1 优先级位图

每个进程会维护一个位图，长度，即比特位个数，为协程的优先级数，每一位的取值为0或1，代表进程中是否存在该优先级的协程。在每次插入协程ID或弹出协程ID时，如果某个优先级的队列从空变为非空，或是从非空变为空，都会修改进程位图中的对应位为1或0。

~~在X86架构中有两条位扫描指令【～～～】，可以直接得到一串数位的左起或右起第一个1的位置，借此可以使得【2.3.1】中所描述的调度器弹出最高优先级协程ID的时间复杂度从`O(N)`优化为`O(1)`，从执行数百次判断优化为执行一条指令，但目前在riscv中还没有这条指令。~~

我们在内核中也设置一个位图，长度为协程的优先级数，但每一位的0或1代表的是整个系统的所有进程中，是否存在该优先级的协程，这需要使内核可以访问到所有进程的位图，我们的做法是，指定一个虚拟地址作为进程在用户态访问位图的地址，在进程初始化时，从内核获取一个空闲的物理页面，将指定的进程的位图地址，与此物理页起始地址建立映射，并赋予进程读写的权限，就可以使得进程可以在用户态对位图进行读写，内核也可以直接访问到进程的位图。

我们将进程ID与进程位图的内核地址（如果内核采用对等映射，此时就是物理地址）建立映射，就可以通过遍历进程，找到每个进程对应的位图的内核地址。在每个时钟中断到来时，遍历所有进程的位图，更新内核位图，这里只需要对所有进程位图进行或运算，只要其中有一个进程的一个协程属于该优先级，内核位图中的对应位就是1，只有当所有进程都不存在该优先级的协程，内核位图的对应位才会是0，将所有进程位图的或运算结果赋值给内核位图，即完成了更新。

#### 2.3.2.2 基于优先级位图的全局调度

在系统具备了进程位图和内核位图之后，就可以进一步完善我们的调度机制。

有两种原因会导致一个协程退出执行，让出线程栈，即：执行结束和主动让出。无论是哪种情况，都会在之后进入下一轮循环，再次访问调度器获取协程并执行。在进入下一个循环之前，我们读取进程位图与内核位图，比较二者记录的最高优先级，相当于是在查询其他进程中是否存在更高优先级的协程，如果本进程中的协程最高优先级小于内核位图中记录的所有进程中的协程最高优先级，就会让出当前处理器；否则，继续执行。

在每个时钟中断到来，更新完内核位图之后，都会调度执行拥有整个系统的最高优先级协程的进程，该进程会调度执行进程的的最高优先级协程，也就是整个系统的最高优先级协程。

在一个时钟中断之内，进程的位图会随着协程的创建与回收而发生变化，但各个进程的位图变化在下一次时钟中断之前，不会同步到内核位图，所以有两种情况需要讨论：

1. 某个进程创建了一个协程，其优先级大于之前系统中记录的协程最高优先级，此时这个协程执行器会继续执行，在下一个循环中取出该优先级的协程执行。这种情况是符合预期的。

2. 进程中记录的最高优先级协程只有唯一一个，当这个协程执行完毕且没有插入相同或更高优先级的协程时，进程位图的最高优先级位会由1变为0，比较位图时，因为内核位图记录了更高的协程优先级（实际上该协程已经被执行完毕），而让出处理器，此时调度的进程就不一定拥有实际的最高优先级协程。

   针对这种情况，我们可以在每次进程让出处理器时再次更新位图，做到每当有协程执行，都必然是整个系统之内的最高优先级协程，但出于两个原因我们没有采取这种做法，而是允许一个时钟中断之内存在调度非最高优先级的协程的可能：

   1. 一个时钟中断之内更新多次位图，需要多次遍历所有进程，开销较大；
   2. 在每次时钟中断到来时都会更新位图并调度最高优先级协程执行；

## 2.4 Excutor and Asynchronization 

 Excutor是模型中的协程管理机构，负责管理上文提到的协程数据机构，优先级队列，以及本节要介绍的协程的唤醒机制。

当一个协程执行退出执行，让出所占据的线程栈时，有两种情况：

1. 协程执行完毕，协程主函数执行完成并返回，此时会根据协程ID查找到协程的数据结构并释放其所占据的堆内存；
2. 协程未执行完毕，由于等待某个事件到来而主动让出，此时的做法是，不把协程ID插入回调度队列，而直接进入下一轮循环，访问调度器取出下一个协程执行。当主动让出的协程等待的事件到来时，进行唤醒操作，也就是把被唤醒的协程ID插回调度队列。这就是本模型中的协程的异步机制。这样的设计保证了调度器的工作效率，调度队列里的每一个协程都处于可以立即执行的就绪状态，访问调度队列时不用判断协程的状态，也不会访问到等待状态的协程。

现在我们知道，要完成唤醒一个协程的操作，需要协程ID，协程优先级，优先级队列的地址。我们可以将这三个变量封装为一个数据结构称之为TaskWaker，并在协程ID和对应的TaskWaker之间建立起映射，当需要唤醒一个协程时，仅需要给出其协程ID。

所以现在的关键问题是，执行等待事件与唤醒操作的协程，怎样拿到等待被唤醒的协程ID。我们在此引入一个基于HashMap实现的数据结构称之为WakerMap，维护整数key值到协程ID的映射。对于等待的协程与执行唤醒操作的协程，它们需要在创建时传入相同的key值（这是容易实现的，只需要使用一个全局计数器），建立起联系，当需要等待的协程执行到等待操作时，把key值与协程ID的键值对插入到WakerMap，之后执行唤醒操作的协程进行唤醒时，就可以根据key值直接查找到需要被唤醒的协程ID，再根据TaskWaker就可以将处于等待状态的协程的协程ID插入回调度队列，完成唤醒操作；如果是执行唤醒操作的协程优先被调度执行，在查询WakerMap时就会查找到空项而直接跳过，当执行等待操作的协程执行时 ，会发现等待的事件早已到来（比如说缓冲区中的数据已经写入完成），便不会主动让出。



基于上述的设计与实现，我们可以将本模型的协程调度概括为：考虑到整个系统（包括用户态和内核）内的处于就绪状态的协程，在每次时钟中断之后，会进入拥有最高优先级协程的地址空间，然后由该进程调度执行最高优先级协程。也就是说，如果用户态存在相比于内核态优先级更高的协程，那么会先调度执行用户态程序。



# 3. PERFORMANCE COMPARISON 

> 8月25日完成
>
> 对rcore的改造；
>
> 实验一：不涉及内核态，完全在用户态的测试；
>
> 实验二：管道读写，有内核态的参与；



我们在rCore OS上引入了这个协程库，使得rCore可以创建和执行协程，并且设计并进行了实验，对比了引用此协程库的rCore与未经修改的rCore，分别使用协程和线程执行相同任务的性能差异。



## 3.1 Experiment A: Test in user mode without syscall

此实验在用户态使用协程或线程进行普通的函数调用，不使用系统调用，没有内核参与。

本节中我们把协程和线程统称为task，设计如下实验：

1. 实验被创建为进程执行，每个进程内创建N个task执行任务，这N个task编号从0到N - 1。在进程开始时获取一个起始时间，在进程退出前获取一个结束时间，以二者时间差作为任务的总执行时间；
2. 每个task先执行读，后执行写；
3. 当读到的全局变量的值等于自己的task编号时，认为读取成功，可以执行写。当读取不成功，即task读到的变量值不等于自己的task编号时，协程使用异步机制主动让出，等待被唤醒；线程则可以采取原地忙等和主动让出两种策略，我们对这两种情况都进行了测试；
4. 编号为i的task读取成功之后执行写操作，把变量值修改为i + 1；



【Figure1: 协程与原地等待的线程】  【Figure2: 协程与主动让出的线程】  



从实验的结果我们可以看出，协程和线程的执行总时间都会随着并发数的增加而增加。协程的增长趋势接近于一条直线，也就是线性增长，而线程用时的增长速度却越来越快。当并发量较小时，协程完成任务的时间比线程要长【XX%】，随着并发量的增加，线程的用时将超过协程，且与协程的差距越来越大，当并发量到达4000时，协程的用时为线程的【XX%】。



## 3.2 Experiment B: Test in user mode with syscall

此实验在用户态进行，每个协程和线程都会使用读写系统调用，有内核参与。

本节中我们把协程和线程统称为task，设计如下实验：

1. 实验被创建为进程执行，每个进程内创建N个task执行任务，这N个task编号从0到N - 1。在进程开始时获取一个起始时间，在进程退出前获取一个结束时间，以二者时间差作为测试的总执行时间；
1. 我们创建N + 1个管道，编号从0到N，管道可以被读写。所使用的管道的工作方式为：只有当写端关闭时，对此管道的读操作才可以读取到数据然后完成读操作；当写端未关闭时，读操作会在内核引发线程切换；
1. 每个task执行管道的读写操作，具体来说，编号为i（0 <= i < N）的task会从编号为i的管道读取数据，待写入端关闭，读取成功后，向编号为i + 1的管道中写入数据，然后关闭编号为i的管道的写端，使得编号为i +1的task可以完成读操作，相当于使用管道把所有task串联起来，对同一个管道的读写操作分别位于编号相邻的两个task中。
1. 所有的task创建完成之后，测试进程的主线程会直接向管道0写入数据然后关闭它的写端，此后随着task的调度和执行，数据就会被编号为0的task从编号为0的管道中读出，然后写入管道1，编号为1的task再从管道1读取数据，然后写入管道2，以此类推；
1. 由于协程具备优先级属性，所以我们可以设置编号为0的协程拥有最高优先级，其余协程按照创建顺序依次插入次高优先级队列，这使得协程严格按照创建顺序执行，当第i + 1个协程执行读操作时，第i个协程必然已经执行完成，使得每次执行读操作都可以读取成功，不会引发线程切换从而创建多个协程执行器。这是利用协程的优先级性质控制协程执行的先后顺序，使其可以在某些场景提高程序性能的一个示例；



【Figure3: 使用读写系统调用的协程和线程】



从【Figure 3】中可以看出，当并发量较小时，协程的总执行时间比线程的多【XXX%】，随着并发量的增加，线程的执行总时间快速增加并超过协程，当并发量到达4000时，协程的总执行时间为线程的【XXX%】。



协程的总执行时间 = (单个协程的平均执行时间  + 平均切换时间 + 平均调度时间 + 平均唤醒开销) * 协程数。当并发量较小时，以上四个部分的总和比线程的总时间大，但是随着任务数量的增加，单个协程的平均执行时间 + 切换时间 + 调度时间 + 唤醒开销只是缓慢增长，我们可以根据协程执行时间的线性增长趋势得出这一推论。但是对于线程来说，增长趋势是一条下凸的曲线，随着并发数的增加，线程的切换时间和调度时间也会快速增加，使其与相同并发数的协程执行时间差距越来越大。



# 4. CONCLUSION

> 8月26日完成



本文提出并实现了一个协程模型，一个Rust操作系统可以利用此协程库在用户态和内核态创建并执行协程。协程基于优先级调度运行，协程具备优先级属性。我们基于Linux的O(1)调度算法，设计了进程的协程优先级位图和内核的协程优先级位图，使得协程的调度不再是各个进程之内的独立行为，而是可以被内核统一控制，使得整个系统内，某些对于执行时间敏感的协程可以被优先调度，而一些对于执行时间不敏感的协程则可以设置较低优先级，减少与高优先级任务的争抢，使处理器可以更灵活、更科学地被分配。

我们在rCore OS上引入了此协程库并进行了性能对比实验，实验结果显示，并不是在所有情况下协程的性能都优于线程。当并发量较小时，协程的执行时间会大于线程，这是由于运行协程所需要的基本开销，如调度、切换和唤醒，对于并发数较小时的任务量来说，影响较大，但随着并发量的增加，协程的运行开销增长缓慢，而线程的运行开销增长迅速，且此劣势带来的影响越来越大，使得线程的执行时间超过协程，且二者差距越来越大。



# REFERENCES